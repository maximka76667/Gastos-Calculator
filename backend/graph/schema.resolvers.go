package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"gastos-counter-api/graph/model"
)

// Members is the resolver for the members field.
func (r *groupResolver) Members(ctx context.Context, obj *model.Group) ([]*model.User, error) {
	return nil, nil
}

// User is the resolver for the user field.
func (r *groupUserResolver) User(ctx context.Context, obj *model.GroupUser) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Group is the resolver for the group field.
func (r *groupUserResolver) Group(ctx context.Context, obj *model.GroupUser) (*model.Group, error) {
	panic(fmt.Errorf("not implemented: Group - group"))
}

// Role is the resolver for the role field.
func (r *groupUserResolver) Role(ctx context.Context, obj *model.GroupUser) (*model.Role, error) {
	panic(fmt.Errorf("not implemented: Role - role"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	var users []*model.User

	// Fetch raw users from the database
	if err := r.DB.Find(&users).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch users: %w", err)
	}

	return users, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// var user *model.User

	// err := r.DB.Model(model.User{}).Where("id = ?", id).Select(&user).Error

	// if err != nil {
	// 	return nil, fmt.Errorf("failed to fetch user by id: %v", err)
	// }

	return nil, nil
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context) ([]*model.Group, error) {
	// var groups []model.Group

	// err := r.DB.Model(&groups).Select()

	// if err != nil {
	// 	return nil, fmt.Errorf("failed to fetch groups %v", err)
	// }

	// var result []*model.Group
	// for _, group := range groups {
	// 	result = append(result, &group)
	// }

	return nil, nil
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id string) (*model.Group, error) {
	// var group model.Group

	// err := r.DB.Model(&group).Where("id = ?", id).Select()

	// if err != nil {
	// 	return nil, fmt.Errorf("failed to fetch group by id: %v", err)
	// }

	return nil, nil
}

// Expenses is the resolver for the expenses field.
func (r *queryResolver) Expenses(ctx context.Context, groupID string) ([]*model.Expense, error) {
	panic(fmt.Errorf("not implemented: Expenses - expenses"))
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *model.User, groupID string) (*model.Role, error) {
	var role *model.Role

	err := r.DB.Model(&model.Role{}).
		Table("group_users").
		Select("roles.id, roles.name").
		Joins("JOIN roles ON group_users.role_id = roles.id").
		Where("group_users.user_id = ? AND group_users.group_id = ?", obj.ID, groupID).
		Scan(&role).Error

	if err != nil {
		return nil, err
	}

	return role, nil
}

// ParticipatesIn is the resolver for the participatesIn field.
func (r *userResolver) ParticipatesIn(ctx context.Context, obj *model.User) ([]*model.Group, error) {
	// Fetch groups from the `group_users` table for the given user ID
	var groups []*model.Group

	err := r.DB.Model(&model.Group{}).
		Joins("JOIN group_users ON groups.id = group_users.group_id").
		Where("group_users.user_id = ?", obj.ID).
		Find(&groups).Error

	if err != nil {
		return nil, err
	}

	return groups, nil
}

// Group returns GroupResolver implementation.
func (r *Resolver) Group() GroupResolver { return &groupResolver{r} }

// GroupUser returns GroupUserResolver implementation.
func (r *Resolver) GroupUser() GroupUserResolver { return &groupUserResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type groupResolver struct{ *Resolver }
type groupUserResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
