package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"gastos-counter-api/graph/model"
	"gastos-counter-api/helpers"
	"gastos-counter-api/utils"
)

// User is the resolver for the user field.
func (r *expenseResolver) User(ctx context.Context, obj *model.Expense) (*model.User, error) {
	return helpers.GetUserByID(r.DB, obj.UserId)
}

// Group is the resolver for the group field.
func (r *expenseResolver) Group(ctx context.Context, obj *model.Expense) (*model.Group, error) {
	return helpers.GetGroupById(r.DB, obj.GroupId)
}

// Members is the resolver for the members field.
func (r *groupResolver) Members(ctx context.Context, obj *model.Group) ([]*model.User, error) {
	return helpers.GetUsersByGroupId(r.DB, obj.ID)
}

// User is the resolver for the user field.
func (r *groupUserResolver) User(ctx context.Context, obj *model.GroupUser) (*model.User, error) {
	return helpers.GetUserByID(r.DB, obj.UserId)
}

// Group is the resolver for the group field.
func (r *groupUserResolver) Group(ctx context.Context, obj *model.GroupUser) (*model.Group, error) {
	return helpers.GetGroupById(r.DB, obj.GroupId)
}

// Role is the resolver for the role field.
func (r *groupUserResolver) Role(ctx context.Context, obj *model.GroupUser) (*model.Role, error) {
	return helpers.GetRoleById(r.DB, obj.RoleId)
}

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, user model.CreateUserInput) (*model.User, error) {
	hashedPassword, err := utils.HashPassword(user.Password)

	if err != nil {
		return nil, err
	}

	newUser := model.User{
		Email:             user.Email,
		FullName:          user.FullName,
		Username:          user.Username,
		PreferredCurrency: *user.PreferredCurrency,
		Password:          hashedPassword,
	}

	if err = r.DB.Create(&newUser).Error; err != nil {
		return nil, err
	}

	return &newUser, nil
}

// EditUser is the resolver for the editUser field.
func (r *mutationResolver) EditUser(ctx context.Context, id string, user model.EditUserInput) (*model.User, error) {
	userToUpdate, err := helpers.GetUserByID(r.DB, id)

	if err != nil {
		return nil, err
	}

	// Update the fields of the user
	if user.Email != nil {
		userToUpdate.Email = *user.Email
	}
	if user.FullName != nil {
		userToUpdate.FullName = *user.FullName
	}
	if user.Username != nil {
		userToUpdate.Username = *user.Username
	}
	if user.PreferredCurrency != nil {
		userToUpdate.PreferredCurrency = *user.PreferredCurrency
	}

	if user.Password != nil {
		hashedPassword, err := utils.HashPassword(*user.Password)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", err)
		}
		userToUpdate.Password = hashedPassword
	}

	// Save the updated user
	if err := r.DB.Save(&userToUpdate).Error; err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	return userToUpdate, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.User, error) {
	userToDelete, err := helpers.GetUserByID(r.DB, id)

	if err != nil {
		return nil, err
	}

	if err := r.DB.Delete(&userToDelete).Error; err != nil {
		return nil, fmt.Errorf("failed to delete user: %w", err)
	}

	// Return the deleted user data, or just return nil if you don't need it
	return userToDelete, nil
}

// AddGroup is the resolver for the addGroup field.
func (r *mutationResolver) AddGroup(ctx context.Context, group model.CreateGroupInput) (*model.Group, error) {
	newGroup := model.Group{
		Name: group.Name,
	}

	// Save the new group to the database
	if err := r.DB.Create(&newGroup).Error; err != nil {
		return nil, fmt.Errorf("failed to create group: %w", err)
	}

	return &newGroup, nil
}

// EditGroup is the resolver for the editGroup field.
func (r *mutationResolver) EditGroup(ctx context.Context, id string, group model.EditGroupInput) (*model.Group, error) {
	groupToUpdate, err := helpers.GetGroupById(r.DB, id)
	if err != nil {
		return nil, err
	}

	// Update the fields of the group
	if group.Name != nil {
		groupToUpdate.Name = *group.Name
	}

	// Save the updated group
	if err := r.DB.Save(&groupToUpdate).Error; err != nil {
		return nil, fmt.Errorf("failed to update group: %w", err)
	}

	return groupToUpdate, nil
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string) (*model.Group, error) {
	groupToDelete, err := helpers.GetGroupById(r.DB, id)
	if err != nil {
		return nil, err
	}

	if err := r.DB.Delete(&groupToDelete).Error; err != nil {
		return nil, fmt.Errorf("failed to delete group: %w", err)
	}

	// Return the deleted group data, or just return nil if you don't need it
	return groupToDelete, nil
}

// AddExpense is the resolver for the addExpense field.
func (r *mutationResolver) AddExpense(ctx context.Context, expense model.CreateExpenseInput) (*model.Expense, error) {
	newExpense := model.Expense{
		UserId:       expense.UserID,
		GroupId:      expense.GroupID,
		IsMain:       expense.IsMain,
		Name:         expense.Name,
		CurrencyCode: *expense.CurrencyCode,
		Amount:       expense.Amount,
	}

	// Save the new expense to the database
	if err := r.DB.Create(&newExpense).Error; err != nil {
		return nil, fmt.Errorf("failed to create expense: %w", err)
	}

	return &newExpense, nil
}

// EditExpense is the resolver for the editExpense field.
func (r *mutationResolver) EditExpense(ctx context.Context, id string, expense model.EditExpenseInput) (*model.Expense, error) {
	// Fetch the existing expense by id
	expenseToUpdate, err := helpers.GetExpenseById(r.DB, id)
	if err != nil {
		return nil, fmt.Errorf("expense not found: %w", err)
	}

	// Update fields if provided
	if expense.UserID != nil {
		expenseToUpdate.UserId = *expense.UserID
	}
	if expense.GroupID != nil {
		expenseToUpdate.GroupId = *expense.GroupID
	}
	if expense.Amount != nil {
		expenseToUpdate.Amount = *expense.Amount
	}
	if expense.IsMain != nil {
		expenseToUpdate.IsMain = *expense.IsMain
	}
	if expense.Name != nil {
		expenseToUpdate.Name = *expense.Name
	}
	if expense.CurrencyCode != nil {
		expenseToUpdate.CurrencyCode = *expense.CurrencyCode
	}

	// Save the updated expense to the database
	if err := r.DB.Save(&expenseToUpdate).Error; err != nil {
		return nil, fmt.Errorf("failed to update expense: %w", err)
	}

	// Return the updated expense
	return expenseToUpdate, nil
}

// DeleteExpense is the resolver for the deleteExpense field.
func (r *mutationResolver) DeleteExpense(ctx context.Context, id string) (*model.Expense, error) {
	expenseToDelete, err := helpers.GetExpenseById(r.DB, id)
	if err != nil {
		return nil, err
	}

	if err := r.DB.Delete(&expenseToDelete).Error; err != nil {
		return nil, fmt.Errorf("failed to delete expense: %w", err)
	}

	// Return the deleted expense data, or just return nil if you don't need it
	return expenseToDelete, nil
}

// AddRole is the resolver for the addRole field.
func (r *mutationResolver) AddRole(ctx context.Context, role model.CreateRoleInput) (*model.Role, error) {
	newRole := model.Role{
		Name: role.Name,
	}

	// Save the new role to the database
	if err := r.DB.Create(&newRole).Error; err != nil {
		return nil, fmt.Errorf("failed to create role: %w", err)
	}

	return &newRole, nil
}

// EditRole is the resolver for the editRole field.
func (r *mutationResolver) EditRole(ctx context.Context, id string, role model.EditRoleInput) (*model.Role, error) {
	roleToUpdate, err := helpers.GetRoleById(r.DB, id)
	if err != nil {
		return nil, err
	}

	// Update the fields of the role
	if role.Name != nil {
		roleToUpdate.Name = *role.Name
	}

	// Save the updated role
	if err := r.DB.Save(&roleToUpdate).Error; err != nil {
		return nil, fmt.Errorf("failed to update role: %w", err)
	}

	return roleToUpdate, nil
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id string) (*model.Role, error) {
	roleToDelete, err := helpers.GetRoleById(r.DB, id)
	if err != nil {
		return nil, err
	}

	if err := r.DB.Delete(&roleToDelete).Error; err != nil {
		return nil, fmt.Errorf("failed to delete role: %w", err)
	}

	// Return the deleted role data, or just return nil if you don't need it
	return roleToDelete, nil
}

// AddGroupUser is the resolver for the addGroupUser field.
func (r *mutationResolver) AddGroupUser(ctx context.Context, groupUser model.CreateGroupUserInput) (*model.GroupUser, error) {
	newGroupUser := model.GroupUser{
		GroupId: groupUser.GroupID,
		UserId:  groupUser.UserID,
		RoleId:  groupUser.RoleID,
	}

	// Save the new group-user relationship to the database
	if err := r.DB.Create(&newGroupUser).Error; err != nil {
		return nil, fmt.Errorf("failed to create group user: %w", err)
	}

	return &newGroupUser, nil
}

// EditGroupUser is the resolver for the editGroupUser field.
func (r *mutationResolver) EditGroupUser(ctx context.Context, groupID string, userID string, groupUser model.EditGroupUserInput) (*model.GroupUser, error) {
	groupUserToUpdate, err := helpers.GetGroupUser(r.DB, groupID, userID)
	if err != nil {
		return nil, err
	}

	// Update the fields of the group-user relationship
	if groupUser.GroupID != nil {
		groupUserToUpdate.GroupId = *groupUser.GroupID
	}
	if groupUser.UserID != nil {
		groupUserToUpdate.UserId = *groupUser.UserID
	}
	if groupUser.RoleID != nil {
		groupUserToUpdate.RoleId = *groupUser.RoleID
	}

	// Save the updated group-user relationship
	if err := r.DB.Save(&groupUserToUpdate).Error; err != nil {
		return nil, fmt.Errorf("failed to update group user: %w", err)
	}

	return groupUserToUpdate, nil
}

// DeleteGroupUser is the resolver for the deleteGroupUser field.
func (r *mutationResolver) DeleteGroupUser(ctx context.Context, groupID string, userID string) (*model.GroupUser, error) {
	groupUserToDelete, err := helpers.GetGroupUser(r.DB, groupID, userID)

	if err != nil {
		return nil, err
	}

	if err := r.DB.Delete(&groupUserToDelete).Error; err != nil {
		return nil, fmt.Errorf("failed to delete group user: %w", err)
	}

	// Return the deleted group-user relationship, or just return nil if you don't need it
	return groupUserToDelete, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	return helpers.GetUsers(r.DB)
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	return helpers.GetUserByID(r.DB, id)
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context) ([]*model.Group, error) {
	return helpers.GetGroups(r.DB)
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id string) (*model.Group, error) {
	return helpers.GetGroupById(r.DB, id)
}

// Expenses is the resolver for the expenses field.
func (r *queryResolver) Expenses(ctx context.Context) ([]*model.Expense, error) {
	return helpers.GetExpenses(r.DB)
}

// ExpensesByGroup is the resolver for the expensesByGroup field.
func (r *queryResolver) ExpensesByGroup(ctx context.Context, groupID string) ([]*model.Expense, error) {
	return helpers.GetExpensesByGroupId(r.DB, groupID)
}

// ExpensesByUser is the resolver for the expensesByUser field.
func (r *queryResolver) ExpensesByUser(ctx context.Context, userID string) ([]*model.Expense, error) {
	return helpers.GetExpensesByUserId(r.DB, userID)
}

// Expense is the resolver for the expense field.
func (r *queryResolver) Expense(ctx context.Context, groupID string, userID string) (*model.Expense, error) {
	return helpers.GetExpense(r.DB, groupID, userID)
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]*model.Role, error) {
	return helpers.GetRoles(r.DB)
}

// Role is the resolver for the role field.
func (r *queryResolver) Role(ctx context.Context, id string) (*model.Role, error) {
	return helpers.GetRoleById(r.DB, id)
}

// GroupUsers is the resolver for the groupUsers field.
func (r *queryResolver) GroupUsers(ctx context.Context) ([]*model.GroupUser, error) {
	return helpers.GetGroupUsers(r.DB)
}

// GroupUsersByGroup is the resolver for the groupUsersByGroup field.
func (r *queryResolver) GroupUsersByGroup(ctx context.Context, groupID string) ([]*model.GroupUser, error) {
	return helpers.GetGroupUsersByGroup(r.DB, groupID)
}

// GroupUsersByUser is the resolver for the groupUsersByUser field.
func (r *queryResolver) GroupUsersByUser(ctx context.Context, userID string) ([]*model.GroupUser, error) {
	return helpers.GetGroupUsersByUser(r.DB, userID)
}

// GroupUser is the resolver for the groupUser field.
func (r *queryResolver) GroupUser(ctx context.Context, groupID string, userID string) (*model.GroupUser, error) {
	return helpers.GetGroupUser(r.DB, groupID, userID)
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *model.User, groupID string) (*model.Role, error) {
	return helpers.GetRole(r.DB, obj.ID, groupID)
}

// ParticipatesIn is the resolver for the participatesIn field.
func (r *userResolver) ParticipatesIn(ctx context.Context, obj *model.User) ([]*model.Group, error) {
	return helpers.GetGroupsByUserId(r.DB, obj.ID)
}

// Expense returns ExpenseResolver implementation.
func (r *Resolver) Expense() ExpenseResolver { return &expenseResolver{r} }

// Group returns GroupResolver implementation.
func (r *Resolver) Group() GroupResolver { return &groupResolver{r} }

// GroupUser returns GroupUserResolver implementation.
func (r *Resolver) GroupUser() GroupUserResolver { return &groupUserResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type expenseResolver struct{ *Resolver }
type groupResolver struct{ *Resolver }
type groupUserResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
